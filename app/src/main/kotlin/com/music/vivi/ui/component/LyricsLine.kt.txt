package com.music.vivi.ui.component

import androidx.compose.foundation.background
import androidx.compose.foundation.combinedClickable
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.ExperimentalLayoutApi
import androidx.compose.foundation.layout.FlowRow
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.derivedStateOf
import androidx.compose.runtime.getValue
import androidx.compose.runtime.remember
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.TileMode
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.text.ExperimentalTextApi
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.music.vivi.lyrics.LyricsEntry
import com.music.vivi.ui.screens.settings.LyricsPosition
import androidx.compose.runtime.collectAsState

@OptIn(ExperimentalTextApi::class, ExperimentalLayoutApi::class)
@Composable
fun LyricsLine(
    entry: LyricsEntry,
    nextEntryTime: Long?,
    currentTime: Long,
    isSynced: Boolean,
    isActive: Boolean,
    distanceFromCurrent: Int,
    lyricsTextPosition: LyricsPosition,
    textColor: Color,
    showRomanized: Boolean,
    onClick: () -> Unit,
    onLongClick: () -> Unit,
    isSelected: Boolean,
    isSelectionModeActive: Boolean,
    modifier: Modifier = Modifier
) {
    val duration = remember(entry.time, nextEntryTime) {
        if (nextEntryTime != null) nextEntryTime - entry.time else 3000L
    }

    // Use 85% of the duration for animation to finish before next line
    // This accounts for the 300ms lookahead in findCurrentLineIndex
    val activeDuration = remember(duration) {
        (duration * 0.85).toLong().coerceAtLeast(500L)
    }

    // Calculate word timings based on proportional length
    val wordData = remember(entry.text, activeDuration) {
        val words = entry.text.split(" ")
        val totalChars = entry.text.length

        var accumulatedTime = 0L
        words.mapIndexed { index, word ->
            val wordLength = word.length
            val includeSpace = index < words.lastIndex
            val charCount = if (includeSpace) wordLength + 1 else wordLength

            val wordStart = accumulatedTime
            val wordDuration = (activeDuration * charCount.toFloat() / totalChars).toLong()
            val wordEnd = wordStart + wordDuration

            accumulatedTime += wordDuration

            Triple(word, wordStart, wordEnd)
        }
    }

    val itemModifier = modifier
        .fillMaxWidth()
        .clip(RoundedCornerShape(8.dp))
        .combinedClickable(
            enabled = true,
            onClick = onClick,
            onLongClick = onLongClick
        )
        .background(
            if (isSelected && isSelectionModeActive)
                MaterialTheme.colorScheme.primary.copy(alpha = 0.3f)
            else Color.Transparent
        )
        .padding(horizontal = 24.dp, vertical = 8.dp)
        .graphicsLayer {
            val targetAlpha = when {
                !isSynced || (isSelectionModeActive && isSelected) -> 1f
                isActive -> 1f
                distanceFromCurrent == 1 -> 0.7f
                distanceFromCurrent == 2 -> 0.4f
                else -> 0.2f
            }
            alpha = targetAlpha

            val targetScale = when {
                !isSynced || isActive -> 1f
                distanceFromCurrent == 1 -> 0.95f
                distanceFromCurrent >= 2 -> 0.9f
                else -> 1f
            }
            scaleX = targetScale
            scaleY = targetScale
        }

    Column(
        modifier = itemModifier,
        horizontalAlignment = when (lyricsTextPosition) {
            LyricsPosition.LEFT -> Alignment.Start
            LyricsPosition.CENTER -> Alignment.CenterHorizontally
            LyricsPosition.RIGHT -> Alignment.End
        }
    ) {
        // Main Lyrics Text
        if (isActive && isSynced) {
            FlowRow(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = when (lyricsTextPosition) {
                    LyricsPosition.LEFT -> androidx.compose.foundation.layout.Arrangement.Start
                    LyricsPosition.CENTER -> androidx.compose.foundation.layout.Arrangement.Center
                    LyricsPosition.RIGHT -> androidx.compose.foundation.layout.Arrangement.End
                }
            ) {
                wordData.forEachIndexed { index, (word, startRelative, endRelative) ->
                    // Time elapsed since this line became active (no offset)
                    val lineRelTime = (currentTime - entry.time).coerceAtLeast(0L)

                    // Calculate word fill progress (0f to 1f)
                    val wordProgress by remember(lineRelTime, startRelative, endRelative) {
                        derivedStateOf {
                            when {
                                lineRelTime >= endRelative -> 1f
                                lineRelTime < startRelative -> 0f
                                else -> {
                                    val dur = endRelative - startRelative
                                    if (dur <= 0) 1f
                                    else (lineRelTime - startRelative).toFloat() / dur
                                }
                            }
                        }
                    }

                    // Create gradient brush for fill animation
                    val brush = remember(wordProgress, textColor) {
                        val filled = textColor
                        val empty = textColor.copy(alpha = 0.3f)

                        // Smooth gradient edge width (20% of word)
                        val edgeWidth = 0.15f

                        when {
                            wordProgress <= 0f -> {
                                // Not started - fully empty
                                Brush.linearGradient(colors = listOf(empty, empty))
                            }
                            wordProgress >= 1f -> {
                                // Complete - fully filled
                                Brush.linearGradient(colors = listOf(filled, filled))
                            }
                            else -> {
                                // In progress - create gradient
                                val stops = mutableListOf<Pair<Float, Color>>()

                                // Filled region starts at 0
                                val filledEnd = (wordProgress - edgeWidth / 2).coerceAtLeast(0f)
                                val gradientEnd = (wordProgress + edgeWidth / 2).coerceAtMost(1f)

                                if (filledEnd > 0f) {
                                    stops.add(0f to filled)
                                    stops.add(filledEnd to filled)
                                }

                                // Gradient transition
                                if (filledEnd < gradientEnd) {
                                    if (filledEnd == 0f) {
                                        stops.add(0f to filled)
                                    }
                                    stops.add(gradientEnd to empty)
                                }

                                // Empty region to the end
                                if (gradientEnd < 1f) {
                                    stops.add(1f to empty)
                                }

                                Brush.horizontalGradient(
                                    colorStops = stops.toTypedArray(),
                                    tileMode = TileMode.Clamp
                                )
                            }
                        }
                    }

                    Text(
                        text = if (index != wordData.lastIndex) "$word " else word,
                        fontSize = 24.sp,
                        style = TextStyle(brush = brush),
                        fontWeight = FontWeight.ExtraBold
                    )
                }
            }
        } else {
            // Inactive line - single text for performance
            Text(
                text = entry.text,
                fontSize = 24.sp,
                color = textColor.copy(alpha = if (isActive && isSynced) 1f else 0.8f),
                textAlign = when (lyricsTextPosition) {
                    LyricsPosition.LEFT -> TextAlign.Left
                    LyricsPosition.CENTER -> TextAlign.Center
                    LyricsPosition.RIGHT -> TextAlign.Right
                },
                fontWeight = if (isActive && isSynced) FontWeight.ExtraBold else FontWeight.Bold
            )
        }

        // Romanized text (if enabled)
        if (showRomanized) {
            val romanizedText by entry.romanizedTextFlow.collectAsState()
            romanizedText?.let { romanized ->
                Text(
                    text = romanized,
                    fontSize = 18.sp,
                    color = textColor.copy(alpha = 0.8f),
                    textAlign = when (lyricsTextPosition) {
                        LyricsPosition.LEFT -> TextAlign.Left
                        LyricsPosition.CENTER -> TextAlign.Center
                        LyricsPosition.RIGHT -> TextAlign.Right
                    },
                    fontWeight = FontWeight.Normal,
                    modifier = Modifier.padding(top = 2.dp)
                )
            }
        }
    }
}